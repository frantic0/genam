# Generative Acoustic Metamaterial

__genam__ is a python package and a framework for the generative design and optimisation of acoustic metamaterials.


<br />

## Dependencies 

__genam__ scripts run on Salome's Python virtual environment. 

* [Salome 9.8.0](https://salome-platform.org/) – Integration platform for numerical simulation

That means that, rather than executing __genam__ scripts using your Python installation on your terminal, shell or integrated development environment (IDE, e.g. VS Code, Atom or Pylance), you need to run them with Salome. Next section will show how to open scripts on Salome's graphical user interface, or run them with Salome in batch mode in the command line interface. 

The following is the list of third-party software and python modules that aren not installed by default in Salome but are necessary to run __genam__ scripts:

* [ElmerFEM](http://www.csc.fi/elmer) – Multiphysical simulation
* [Paraview](https://www.paraview.org/) – Data analysis and visualization 
* [Python 3.9](https://www.python.org/) and libraries for post-processing and analysis:
  * [numpy](https://www.python.org/)
  * [pandas](https://www.python.org/)
  * [matplotlib](https://www.python.org/)
  * [meshio](https://www.python.org/)
  * [pytorch](https://pytorch.org)

Additionally, you may want to install Jupiter notebooks to run interactive analyis

* [Jupyter Notebooks](https://www.python.org/)

You will also need an IDE or code editor to edit the Python code in your scripts. Here's is a useful thread on how to set up a code editor with Salome.

[Using python salome libraries from a python IDE](https://discourse.salome-platform.org/t/using-python-salome-libraries-from-a-python-ide/63/7)

<br />

## Installation

To install Salome in your system after you download the package, we suggest you unpack Salome to your **home** directory (Linux) or to the following directory (Windows): 

```
C:\SALOME-9.8.0
```

Once you have unpacked Salome, you will find there the following scripts:

* Linux: source ```env_launch.sh``` (generated by ./sat environ SALOME)
* Windows: ```env_launch.bat``` (shipped with SALOME).

You will need to run these to set Salome's virtual environment to install the Python module dependencies listed above. To do so, you have to install a module like ```pandas``` using Salome's virtual environment python and pip, like so:   

```
C:\SALOME-9.8.0\W64\Python\python -m pip install pandas
```

<br />

## Up and Running


Once you have everything set up, start a Salome instance from your command line interface

```
python salome
```

You can also use salome in batch mode, which means without the graphical user interface and environment.  

```
python .\salome -t -w1 
```

For instance, to generate and run a study of the labyrinthine brick #15 using Salome in batch mode  

```
python .\salome -t -w1  .test_quantized_matrix_1_1.py args:15
```

If all goes well, this will generate the geometry and mesh files for labyrinthine brick #15 (.unv and Elmer format files *.mesh), and the .sif template for the Elmer solver to generate a simulation which will be stored in a .vtu file.
  

## Usage 

This section introduces what a typical __genam__ script is and how it is structured. It provides a short and cursory tutorial that break down a script into it most important parts and explains 


A high-level __genam__ script runs within the Salome environment, so it needs to import the main Salome module and request an initialisation. It also interacts files and from specific directories in the file system, from which it reads and/or writes intermediate data for the meshing and simulation stages.


```
import sys
from pathlib import Path

### Salome GEOM and SMESH components
import salome
salome.salome_init()
```

Because the script is running within Salome, which takes over the current working dir, we need to tell Salome where the __genam__ package is installed, like so:   


```
# Set file paths for library and tests  
sys.path.insert(0, r'C:/Users/user/Documents/dev/pipeline')
sys.path.insert(0, r'C:/Users/user/Documents/dev/pipeline/genam')
sys.path.insert(0, r'C:/Users/user/Documents/dev/pipeline/tests')
```

The __genam__ package is structured with a simple namespace that reflects the main concepts and workflow stages that it implements. Typically, we to use geometry and meshing constructs, configuration, data structures and utility functions: 

```
# Genam Lens, mesh configurator
from matrices.quantized_1_1 import quantized_matrix_1_1_x
from genam.lens import Lens
from genam.configuration.lens import configurator as lens_configurator 
from genam.configuration.mesh import configurator as mesh_configurator
from genam.solver import convert_mesh, copy_solver_templates, copy_sif, run_elmer_solver
from genam.analysis import Analysis
```

To create a model of a lens, or a metasurface, you configure it with a matrice of quantized bricks identifiers (between 0 and 15), configure its mesh parameters and name it. 

```
lens_config = lens_configurator( quantized_matrix_1_1 )

lens_name = 'quantized_matrix_1_1' 

lens = Lens( lens_config, mesh_config_selector(3), name = lens_name  )
```

For instance, the matrix configuration for an 8x8 lens of quantised bricks can be something like this:

```
quantized_matrix_8_8 = np.array([ 
                                  [  4,  7, 10, 13, 13, 10,  7,  4 ],
                                  [  5,  9, 13,  3,  3, 13,  9,  5 ],
                                  [ 10, 13,  0,  6,  6,  0, 13, 10 ],
                                  [ 15,  3,  6,  7,  7,  6,  3, 15 ],
                                  [ 15,  3,  6,  7,  7,  6,  3, 15 ],
                                  [ 10, 13,  0,  6,  6,  0, 13, 10 ],
                                  [  5,  9, 13,  3,  3, 13,  9,  5 ],
                                  [  4,  7, 10, 13, 13, 10,  7,  4 ],
                                ])
```

Once the lens is created, you can request the processing of the lens geometry and mesh 

```
lens.process_geometry() 

lens.process_mesh() 
```

Once the pre-processing stage is completed, we can prepare all the data files and paths for running the ElmerSolver simulation.
First we define a dataset path, where all data will be stored - .unv mesh files and solver directories, solver *.mesh files, sif. file.

```
DATASET_PATH = Path('/SAN/uclic/ammdgop/data')              
```

Then we can export the lens mesh data to a __.unv__ file in a dataset subdirectory named after the lens and convert the mesh.
```
UNV_PATH = DATASET_PATH.joinpath( lens_name + '.unv')       

lens.export_mesh( str( UNV_PATH ) ) 

convert_mesh( UNV_PATH ) # run elmergrid convert .unv mesh file to elmer format *.mesh files in a directory 
```

We also need to set up everything the ElmerSolver needs to run, which includes setting up the path for folder where the solver configuration file and templates will be copied to. Only then we can run the solver to obtain the simulation.


```
SOLVER_DATA_PATH = DATASET_PATH.joinpath( lens_name )       
SIF_PATH = Path('test_quantised_matrix.sif')     

copy_solver_templates( SOLVER_DATA_PATH )         
copy_sif( SOLVER_DATA_PATH, SIF_PATH )  

run_elmer_solver( SOLVER_DATA_PATH )
```

Once the ElmerSolver simulation completes and gets its data stored in a __.vtu__ file, we can get values of specific data series like pressure and phase, and analyse specific data points.

```
analysis = Analysis( str(SOLVER_DATA_PATH.joinpath( 'case-40000_t0001.vtu' )) )

find_optimisation_target = lambda points, precision, value: sorted(list(filter( lambda x: x[2] == 0.1 and x[0] < 0 and x[1] < 0, points)))

optimisation_targets = find_optimisation_target(analysis.points, 2, 0.1)
optimisation_target = optimisation_targets[len(optimisation_targets)-1]
optimisation_target_id = analysis.points.index(optimisation_targets[len(optimisation_targets)-1])
optimisation_target_pressure = analysis._absolute_pressure.GetValue(optimisation_target_id)
```



## License